---
layout: default
---
<body class="site">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  

    

      </header>
    </div>




    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
<div class="post-header mb2">
  <h2>Over The Air Firmware Update</h2>
  <span class="post-meta">May, 2016 to October, 2016</span><br>
  
  <span class="post-meta small">
  
    13 minutes read
  
  </span>
</div>
<article class="post-content">
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<p>In this post, I will be talking about the solution that can be used in the IOT systems. </p>

<p>The solution is demonstrated by a small application which updates microcontroller firmware over-the-air through Bluetooth enabled android device. The system is just a proof of concept.</p>

<h3> Use Cases </h3>
<strong>1.</strong>&ensp;Updating firmware of distributed embedded devices by sitting at one central location. For instance, <br />
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; If embedded device is located thousand kilo meters far away from the central location, embedded device manufacturer must be able to update device firmware by sending the firmware to user’s android/ios device. <br />
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;     Ex: Bluetooth enabled - headphone, speakers, home automation system, television etc<br />

<strong>2.</strong>&ensp;Program PIC without using Microchip <a href="http://www.microchipdirect.com/ProductDetails.aspx?Catalog=BuyMicrochip&Category=Cat4_SubCat9&mid=10">programmer/debugger</a>. <br/>
<br/>
<p>These 2 use cases motivated me building this small system.</p>
  
<p>The system consists of <a href="http://www.microchip.com/wwwproducts/en/PIC18F4431">PIC18f4431</a> and <a href="http://www.microchip.com/wwwproducts/en/PIC32MX795F512H">pic32mx795f512h</a> microcontrollers, android device and Bluetooth interface module. This post would be focusing on PIC18f microcontroller boot loader, Android application, and implementation of them.</p>
  
<h3>PIC Boot Loader </h3>
<p>Boot loader is a special firmware loaded into the microcontroller. The boot loader receives application firmware binaries externally via one of the microcontroller serial port (Ex: UART, SPI etc.) and loads them into the pre-determined section of the flash memory.</p>

<figure>
  <center><img src="/OTAFirmwareUpdate/flsh.png" /><center>
  <figcaption><center><span class="post-meta small"> flash memory regions</span><center></figcaption>
</figure>
  
<p>The processor will always start executing a code from a particular (start-up) memory location on reset. Usually in the microcontroller, the application is flashed at the start-up memory location in the absence of bootloader. In the presence of boot loader as shown in the figure "flash memory regions", the boot loader puts the application code in any part of the memory location which user determines (ex: 0x0A00). Whereas boot loader code is loaded at the start-up memory location of the microcontroller.</p> 

<p>The job of the boot loader is to erase the application program memory and load the new incoming binaries via communication port into program memory. The firmware has the reset vector pointer (0x0A00). Right after loading the binaries, the boot loader sets the program counter to reset vector pointer of the firmware to execute the code.</p> 

<p>Before building the application source code in the MPLAB IDE, one must specify the ROM range (after 0x0800h) to load the binaries in to the flash memory other than start-up memory location. ROM range can be specified in the IDE as shown in the figure</p> 
  
  <h3>Boot Loader Source Code</h3>
  
  <p>The boot loader is basically the low level driver of PIC and is implemented in C.  The source code and documentation of it is freely available on the GitHub.</p>
  
  <h4>Algorithm</h4>
1.	Configure IO port<br />
2.	Configure UART at baud rate of <strong>115200</strong> to communicate with the Android device.<br />
3.      Receive NVM address range request command from the host (Android device), in return PIC sends back NVM programmable program memory start and end address. <br />
4.	Receive START command  <br />
5.	Send ready for FIRMWARE_HEADER command to the host.<br />
6.	Receive firmware header. Header consists of Application firmware size, and reset vector address. <br />
7.	Erase application program area and update flash base pointer with the reset vector address of the application.<br />
8.	Receive application binary chunks in packets each of NVM page size of the PIC microcontroller. Load the binaries into the program memory.<br />
9.	Jump to the reset vector location of the app to execute it.<br />

    <h3>Android application (Host)</h3>
 <p> Android device is the host which initiates the firmware update process. The host application is written in Java and consists of user friendly GUI on font end through which user can interact with the app. </p>
  
 <h4> GUI</h4>
  <p>It consists of 3 buttons to select and connect one of the Bluetooth modules from the list, to select one of the hex files from the internal storage of the android device and to update the firmware. List Views displays available hex files and paired Bluetooth devices.</p>
 
<figure>
  <center><img src="/OTAFirmwareUpdate/gui.png" /><center>
  <figcaption><center><span class="post-meta small"> GUI</span><center></figcaption>
</figure>


  <h4> Software</h4>
  
  <p>Software is implemented in JAVA, again the source code and documentation of it is freely available on the GitHub. </p>

<p>Application firmware hex file must be converted to binary file before loading it into the PIC flash memory.</p> 

<p>To convert hex to binary I defined couple of JAVA classes on the android platform. It basically takes hex file as an input and decodes it for the binary, for more information please have look at my another project IntelHexToBin Convertor. For the app, .hex file must be either in the Intel format. MPLAB C compiler generates .hex in the Intel hex format.</p> 

<p>The generated application firmware hex file is stored on the internal storage of the android device. Any number of hex files can be stored on the device. The GUI facilitates user to search the available hex files from the storage and select one of them to send it through Bluetooth communication link to PIC. </p> 
  
  <h4>Algorithm</h4>
  1. List paired Bluetooth modules and select one of them to establish communication link. <br />
2. Read selected hex file.<br />
3. Decode hex file to get the binary data.<br />
4. Divide the huge number of binary data into packets.<br />
5. Send the START command to PIC.<br />
6. Receive FIRMWARE_HEADER request from PIC.<br />
7. Send firmware header. Header consists of Application firmware size, and reset vector address. <br />
8. Receive Header acknowledgement.<br />
9. Send application binary chunks in packets each of NVM page size of the PIC microcontroller.<br />
  
  </div>
    </div>
  </div>


</body>
</html>
